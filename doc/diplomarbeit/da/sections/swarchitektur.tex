%\section*{Software-Architektur}
\cfoot{Philipp Adler}

Die Software-Architektur soll die Bauweise eines Systems abbilden und stellt den Ausgangspunkt eines erfolgreichen Systems dar. Es beschreibt die Vernetzung der Software- und Hardwaresegmente. Des weiteren spielt die Platzierung, sowie die Zusammenarbeit und Anordnung der Softwarekomponenten eine wichtige Rolle.\\
Welche Schnittstellen und Beziehungen stehen zwischen den Elementen, wie findet die Interaktionen zwischen Client und Server statt? All das sind Fragen, die bei der Entwicklung eines Systems bedacht werden müssen. \cite{VERTEILTE_SYSTEME}

\subsubsection{Ablauf}
DSN ist eine Web-Applikation, welche den Benutzern, im Speziellen Schülern, helfen soll, seine Mitschriften organisierter und einfacher zu verwalten.\\
Doch was versteckt hinter einer so großen und komplexen Anwendung? Das folgende Diagramm soll den Ablauf zwischen dem Client-Server verdeutlichen. Dadaraus wird klar ersichtlich, welche Komponenten beim Anmelden eines Users zum Einsatz kommen. Das System wird folgendermaßen aufgebaut:
\begin{itemize}
\item \textbf{Ebene 1: Client}\\ Unser Anwender, der mittels Browser auf unsere Website surft und seine Mitschriften verwaltet.
\item \textbf{Ebene 2: Web-Server}\\ Nginx nimmt HTTP-Anfragen(GET \& POST) entgegen und überprüft die vom User übermittelten Parameter.
\item \textbf{Ebene 3: Applikation-Server}\\ Hinter Ebene 3 verbirgt sich die eigentliche Geschäftslogik, die maßgebend für unser System ist. Bei DSN werden alle HTTP-Anfragen, die an /api/ gehen, an das Web-Framework Django weitergeleitet. Sie ist sozusagen die Schnittstelle zwischen Datenbank und Client.
\item \textbf{Ebene 4: Datenbank-Server}\\ Die Datenbank hat die Aufgabe, wichtige, geheimzuhaltende Daten zu persistieren und bei Anfragen, schnell Antworten zu liefern.\\
Es muss sich nicht unbedingt um einen Datenbank-Server handeln, sondern es gibt die Möglichkeit, seine Daten auf mehreren Stationen aufzuteilen. Weiters können wichtige von unwichtigen Daten getrennt werden. Das steigert die Performance sowie die Ausfallsicherheit.
\end{itemize}
\insertpicture{images/design/Ablaufdiagramm.jpg}{Ablaufdiagramm}{(selfmade)}{itm:ablauf-chart}{0.75}

\begin{enumerate}
\item Im ersten Schritt, ruft der Anwender mittels einer GET-Anfrage, die DSN-Webseite zum ersten Mal auf. Im Hintergrund werden alle notwendigen CSS- und JavaScript-Files geladen.
\item Bevor die Hauptseite erscheint, überprüft der Server die Sprachauswahl. Es besteht die Wahl zwischen zwei Weltsprachen, nämlich Englisch oder Deutsch.\\
Standardmäßig, wird ein POST an \textit{api/change\_lang} mit dem JSON Parameter($\{language:"de"\}$) gesendet.
\item Da es sich um eine /api/ Funktion handelt, leitet der Nginx-Server, der nur für den statischen Teil zuständig ist, die Anfrage weiter zum Django-Server.
\item Hinter der gesendeten Adresse befindet sich eine Funktion, welche den Inhalt der DSN-Seite anhand der übergebenen Parameter auf die gewählte Sprache ändert.
\item Das Ergebnis, die Homepage, in der gewählten Sprache, wird an den Client zurückgeliefert.
\item Im nächsten Schritt möchte sich der bestehende DSN-User beim System anmelden. Dafür klickt er auf den Login-Button, mit der eine GET(/login) Anfrage an dem Server geschickt wird.
\item Mittels REST, Representational State Transfer, wird automatisch auf das Login weitergeleitet. Eine erfolgreiche Anmeldung benötigt, es eine bereits registrierte Email-Adresse, sowie das mindestens 8 stellige Passwort.
\item Durch die Eingabe der Benutzerdaten, schickt der Anwender seine Email-Adresse und das verschlüsselte Passwort, als JSON-Objekt, an den Web-Server. Das POST wird an api/login gesendet.
\item Dynamischen Inhalte werden an Django weitergeleitet.
\item Hinter api/login verbirgt sich eine Funktion, die vom JSON-Objekt die Email-Adresse holt. Mit dieser Info stellt der Server bei der Datenbank die Anfrage, ob der User registriert ist und sich rechtmäßig anmelden darf.
\item Die MongoDB-Datenbank, bestehend aus mehreren Schemas, sucht in der Tabelle \textit{user}. Im Falle eines positiven Ergebnisses, wird geortete User an den Web-Server zurückgegeben.
\item Aufgrund des komplizierten Umgangs mit JSON-Objekten, wird das Datenbankergebnis, mit einem User-Objekt gemappt. Durch den objektorientierten Ansatz, kann ohne viel Aufwand das Passwort kontrolliert werden. Sind alle Überprüfungen fehlerlos, wird der User angemeldet.
\item Je nach Response, erfolgt die Weiterleitung auf die Mangement-Page oder es erscheint eine Fehlermeldung.
\end{enumerate}

%\subsubsection{Services}
%Schittstellen
%Services

\subsubsection{DSN Architektur}
\insertpicture{images/design/architektur.jpg}{Softwarearchitektur}{(selfmade)}{itm:architektur-chart}{0.75}
Unser System besteht aus einem Frontend- und Backend-Server.\\
Der Nginx-Server, Frontend, beinhaltet statitsche Daten, wie HTML-Seiten, CSS- \& JS-Dateien und Bilder. Diese werden durch ein JavaScript File namens routes.js verwaltet. Eingehenden HTTP-Requests werden in diesem File gemappet. Fordert ein User z.B. mit einem GET die Loginpage, wird auf diese weitergeleitet. Jede HTML-Seite hat ihren eigenen Controller, basierend auf JavaScript. Er kümmert sich um die Useraktionen und ändert je nach Anforderung den Inhalt der Website.\\
Sollte es zu komplexeren Aufgaben kommen, wo statischer Inhalt keine Hilfe ist, wird die Kommunikation mit dem Django-Server, Backend, erforderlich. Django ist ein Web Framework, basierend auf Python. Wie bei Frontend, existiert ein File, dass alles managt. Die \textit{urls.py} Datei nimmt HTTP-Anfragen entgegen und delegiert diese auf jeweiligen Funktionen im views Ordner. Diese hantieren mit den empfangenen JSON-Objekten. Handelt es sich bei der Anfrage, um die Auflistung von Schulheften oder Heftinhalten, ist eine DB-Abfrage erforderlich.\\
Dank dem \textit{models.py} File liefert MongoDB kein JSON, sondern spezifizierte Objekte, die die Arbeit erleichtern.
%Dient-Architektur
%Software-Architektur

\subsubsection{Interaktion zwischen JS-Frameworks}
Während der laufenden Entwicklung von DSN, sind bei der Einbindung von JS-Frameworks Probleme aufgetretten. Schwieriger als Gedacht, zeigte sich die Einbindung und Verarbeitung von unserem Textelement CKEditor und Codeelement CodeMirror.\\

Die Texteditor ließ sich ohne viel Aufwand in das bestehende System integrieren. DSN bieten den Anwender die Möglichkeit zwischen Elementen Ansichts- und Elementen im Bearbeitungsmodus zu wählen. Zu Beginn war nur der Bearbeitungsmodus gegeben. Entgegen dem Sinne der Entwickler, wurden Änderungen im Hauptcode des Textelements vorgenommen, um das Problem zu lösen. Nun konnte das JavaScript Framework auf die Useraktionen agieren und die das Textfeld mit den Optionen auf- und zuklappen.\\
Die beiden Modies funktionieren erfreulicherweise, doch wie erfolgt die Persistierung im Hintergrund? Dazu musste AngularJS mit dem CKEditor verbunden werden. So war es möglich, den Text aus dem Element auszulesen, an Django zu senden und schlussendlich in die Datenbank zu speichern. Dadurch war das System in der Lage, die im Bearbeitungsmodus hinterlegten Effekte, korrekt darzustellen.\\

Das Codeelement ist dem Textelement ähnlich, mit der Ausnahme, dass es keine zusätzlichen Funktionen wie Fett, kursiv, etc. bietet. Stattdessen kann der User auswählen, in welcher Syntax sein Code gehighlightet werden soll. Genau diese Funktion wurde zum Problem.\\
Der Inhalt wurde entsprechend formatiert, aber beim nächsten Aufruf war diese vergessen. Wie beim Textelement, kam es bei der Funktion Speichern zu Schwierigkeiten. Wir haben AngularJS so angepasst, dass dieses die benutzerspezifische Sprache in die Datenbank speichert und ausliest. Diese Daten werden an das Codelement übergeben und automatisch formatiert.
