%\section*{User und Rollenmanagement}
\cfoot{Philipp Adler}

\subsubsection{Usermanagment}
Unter dem Begriff Usermanagement versteht sich, dass verwalten und kontrollieren von Benutzerkonten. Es soll dazu dienen jeden registrierten User eindeutig zu identifizieren und zu kontrollieren, ob die monatlichen Raten für einen Pro-Account überwiesen wurden. Außerdem soll die bereits in Anspruch genommene Speicherkapazität überwacht werden. Dazu ist notwendig, dass jeder User durch eine Kombination von Daten, einmalig, unterscheidbar von anderen ist.
\subsubsection{Authentisierung}
Unter Authentisierung versteht man den Nachweis der behaupteten Identität der BenutzerInnen. Im Falle von DSN handelt es sich hierbei um die eindeutige Email-Adresse, welche einmalig im System benutzt wird. Unter der Identität versteht sich die Sicherheit von wem die Information stammt. Jedes handeln eines Benutzers kann jemanden zugewiesen werden.\\
Ein weiterer Identitätspunkt wäre, dass zu geheim haltenden Passwort, welches aus Sicherheitsgründen mindestens 8 Zeichen beinhalten muss. Durch 8 Zeichen möchten wir Cyberkriminelle das Knacken von Passwörtern erschweren. Für die Abschließung der Registrierung müssen die Nutzungsbedingungen akzipiert werden. \grqq{} Allgemeine Geschäftsbedingungen (AGB) sind vertragliche Klauseln, die zur Standardisierung und Konkretisierung von Massenverträgen dienen. Sie werden von einer Vertragspartei einseitig gestellt und bedürfen daher einer bes. Kontrolle, um ihren Missbrauch zu verhindern.\grqq{}\cite{AGB}\\
\cite{VERTEILTE_SYSTEME}\cite{PASSWORT_SCHUTZ}

\includegraphics[width=0.35\textwidth]{images/usermanagement/Registrierung}\\

Um auszuschließen, dass sich eine Software bzw. ein Roboter einen Account auf DSN erzeugt, wird ein Captcha verwendet. Ein Captcha dient zur Sicherheit und soll überprüfen wer die Eingabe getätigt hat. Das Captcha muss serverseitig validiert werden. Mit den Daten des Formulars wird ein weiteres Attribut namens recaptcha erhalten. In diesem steht ein Key der zur Validierung an Google gesendet werden muss. Google möchte zur Validierung den Key, die IP des Users und den Secret App Key. Google gibt dann zurück, ob alles korrekt ist, also ob der User ein menschliches Lebewesen ist. Um die Validierung mehrmals einsetzen zu können, haben wir eine Methode dafür geschrieben:

\begin{lstlisting}
def validate_captcha(recaptcha, ip):
    response = {}
    url = "https://www.google.com/recaptcha/api/siteverify"
    params = {
        'secret': settings.RECAPTCHA_SECRET_KEY,
        'response': recaptcha,
        'remoteip': ip
    }
    verify = requests.get(url, params=params, verify=True)
    verify = verify.json()
    response["status"] = verify.get("success", False)
    if response["status"] == True:
        return True
    else:
        return "Captcha ist nicht valide." 
\end{lstlisting}


Um das Captcha anzuzeigen muss eine JS Lib eingebunden werden \cite{CAPTCHA}.
\begin{lstlisting}
<script src="https://www.google.com/recaptcha/api.js?
onload=vcRecaptchaApiLoaded&render=explicit" async defer></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular-recaptcha/2.2.5/
angular-recaptcha.min.js"></script>
\end{lstlisting}


Dannach kann das Captcha einfach wie folgt ins Form eingebunden werden:
\begin{lstlisting}
<div vc-recaptcha key="publicKey"></div>
\end{lstlisting}

publicKey definiert den Public Key des Recaptchas. Dieser wird im Javascript file über \$scope zugewiesen. Das Captcha wird nun angezeigt. Um zu überprüfen ob es ausgefüllt wurde folgendes unternommen:
\begin{lstlisting}
if(vcRecaptchaService.getResponse() === ""){
    $scope.captchaerror = true;
    $scope.captcha_error = "Bitte loese das Captcha.";
}
\end{lstlisting}

Wenn das Captcha gelöst wurde, kann man damit das Form genau ein Mal absenden. Falls es nochmal abgesendet werden muss, muss das Captcha zurückgesetzt werden. Dies kann wie folgt umgesetzt werden:
\begin{lstlisting}
vcRecaptchaService.reload();
\end{lstlisting}

\includegraphics[width=0.35\textwidth]{images/usermanagement/Captcha}\\

\subsubsection{Datenmodell}
Da Django-Authentifizierungs Funktionalitäten nur für relative DBMS ausgelegt sind, daher für den vorgesehenen Anwendungszweck nicht geeignet sind, mussten Änderungen vorgenommen werden, um die Authentifizierung über MongoDB zu ermöglichen.\\

Im File settings.py muss zu \textit{INSTALLED\_APPS} 
\textit{'mongoengine.django.mongo\_auth'} hinzugefügt werden.
Außerdem muss im selben File folgender Code eingefügt werden:
\begin{lstlisting}
AUTHENTICATION_BACKENDS = (
    'mongoengine.django.auth.MongoEngineBackend',
)

AUTH_USER_MODEL=('mongo_auth.MongoUser')
MONGOENGINE_USER_DOCUMENT = 'dsn.models.User'
\end{lstlisting}

Nun muss das User-Model, das eben definiert wurde, noch im File models.py erstellt werden. Der Code für das Model wurde aus dem entsprechenden Source-Code von MongoEngine \cite{MONGOENGINE} kopiert und an unseren Anwendungszweck angepasst.
\begin{lstlisting}
from mongoengine.django.auth import UserManager, Permission, \
 	make_password, check_password, SiteProfileNotAvailable, \
 	_user_get_all_permissions, _user_has_module_perms, _user_has_perm
from mongoengine.django import auth
class User(Document):
    id = ObjectIdField(unique=True, required=True, primary_key=True)
    email = EmailField(unique=True, required=True)
    first_name = StringField(max_length=30)
    last_name = StringField(max_length=30)
    password = StringField(max_length=128)
    is_staff = BooleanField(default=False)
    is_prouser = BooleanField(default=False)
    is_active = BooleanField(default=True)
    is_superuser = BooleanField(default=False)
    last_login = DateTimeField(default=datetime.datetime.now())
    date_joined = DateTimeField(default=datetime.datetime.now())
    passwordreset= EmbeddedDocumentField(PasswordReset)

    user_permissions = ListField(ReferenceField(Permission))

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['last_name', 'first_name']

    meta = {
        'allow_inheritance': True,
        'indexes': [
            {'fields': ['email'], 'unique': True, 'sparse': True}
        ]
    }

   [...]

    ATclassmethod
    def create_user(cls, email, password, first_name, last_name):
        now = datetime.datetime.now()

   [...]
 	  user = cls(id=ObjectId(), email=email, date_joined=now, \
 				first_name=first_name, last_name=last_name)
        user.set_password(password)
        user.save()
        return user

    [...]
\end{lstlisting}

Außerdem muss in \textit{models.py} noch ein UserManager erstellt werden:
\begin{lstlisting}
class AuthUserManager(UserManager):
    def create_user(self, email, password, first_name, last_name):
        if email and password:
            try:
                User.objects.get(email=email)
                return None
            except DoesNotExist:
                try:
                    email_name, domain_part = email.strip().split('AT', 1)
                except ValueError:
                    pass
                else:
                    email = 'AT'.join([email_name, domain_part.lower()])

                user = User(username=email, email=email, \
 					first_name=first_name, last_name=last_name)
                user.set_password(password)
                user.save()
                return user
        else:
            return None

    def create_superuser(self, email, password, first_name, last_name):
        if email and password:
            try:
                User.objects.get(email=email)
                return None
            except DoesNotExist:
                try:
                    email_name, domain_part = email.strip().split('AT', 1)
                
 	    except ValueError:
                    pass
                else:
                    email = 'AT'.join([email_name, domain_part.lower()])

                user = User(email=email, is_superuser=True, \
 					first_name=first_name, last_name=last_name)
                user.set_password(password)
                user.save()
                return user
        else:
            return None
\end{lstlisting}

Da MongoDB den PrimaryKey als ObjectId verlang, muss im bestehenden Original Django-Code folgende Änderungen vorgenommen werden \cite{ISSUE}:
Im File \textit{usr/local/lib/python3.4/dist-packages/django/db/models/fields} in Zeile 964: 
\textit{return int(value)}
ändern zu:
\textit{return value}
Im File /usr/local/lib/python3.4/dist-packages/django/contrib/auth in Zeile 111:
\textit{request.session[SESSION\_KEY] = user.\_meta.pk.value\_to\_string(user)}
ändern zu:
\textit{try:
 	request.session[SESSION\_KEY] = user.\_meta.pk.value\_to\_string(user)
except Exception:
 	request.session[SESSION\_KEY] = user.id}
 	
\subsubsection{Email}
Um den Registrierungsprozess zu beenden, wird dem nahestehenden User ein Token per Mail zugesendet. Dieser dient der Identifizierung und Authentifizierung und könnte folgendermaßen aussehen http://digitalschoolnotes.com/validate/
\\dad9574635aad7d6549536db38f7839c042f7704b3bd74acc427f075d0601470. Bei der Erstellung eines solchen Tokens werden man Email-Adresse des Benutzer und das aktuelle Datum kombiniert. Diese werden miteinander verknüpft, in einen Hash umgewandelt und in die Datenbank abgespeichert. \textit{"validatetoken" : 
\\"f043ea6e44aea716d08ae2cb70d91bcbb50196da1eb89b4727c124508dbf0d85"}\\
Das Datum dient dazu um dem Token ein Zeitstempel zu geben, dieser bezweckt die Gültigkeit. Wenn dieser Hash nicht in den nächsten 24 Stunden verwendet wird, dann ist der Zeitstempel abgelaufen und es muss ein neuer angefordert werden. Hingegen die Email Adresse dient dem Nachweis, welcher Account aktiviert wird.
Im File authentication/registration.py in Zeile 23:
\begin{lstlisting}
def create_validation_token(email):
    user = User.objects.get(email=email)
    now = datetime.datetime.now()
    to_hash = (str(user.id) + str(now)).encode('utf-8')
    hashed = hashlib.sha256(to_hash).hexdigest()
    hashed = str(hashed)
    user.validatetoken = hashed
    user.save()
    return 'http://digitalschoolnotes.com/validate/' + hashed
\end{lstlisting}

Um eine Email verschicken zu können müssen folgende Konfigurationen unternommen werden. Als erstes muss im \textit{settings.py} der Email Server definiert werden.
\begin{lstlisting}
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'mxf92d.netcup.net'
EMAIL_HOST_USER = 'noreplyATdigitalschoolnotes.com'
EMAIL_HOST_PASSWORD = 'passwort'
EMAIL_PORT = 25
EMAIL_USE_TLS = False
DEFAULT_FROM_EMAIL = EMAIL_HOST_USER
\end{lstlisting}

\subsubsection{Anmelden}
Wenn der neue Benutzer den Registrierprozess erfolgreich absolviert hat, steht es jetzt frei sich anzumelden. Entweder durch Angabe der Email-Adresse und Passwort oder mittels OAuth. Mit OAuth besteht die Möglichkeit die Registrierung auszulassen und sich direkt anzumelden. OAuth steht für Open Authentication und bietet dem Nutzer die Möglichkeit Daten über einen Webserverice auszutauschen. „OAuth sichert die Programmschnittstelle von Web-Anwendungen ab und verwendet für die Übertragung der Nutzeridentifikation dessen Passwort und einen Token“\cite{OAUTH}. Bei dem Zugriff auf die sensiblen Daten muss der Benutzer keine zusätzlichen Information und auch keine Identität preisgeben. Der Provider holt sich die Benutzerdaten von Facebook oder Google+ und erstellt für den User einen Account.

\includegraphics[width=0.35\textwidth]{images/usermanagement/Anmelden}\\

Um einen Benutzer anzumelden, muss zunächst ein User-Objekt mit der übergebenen Email Adresse von der Datenbank abgefragt werden. Sollte diese E-Mail Adresse keinem Benutzer zugeordnet sein, existiert der Benutzer noch nicht. Ansonsten muss mit \textit{.check\_password(...)} das eingegebene Passwort überprüft werden. Sollte dieses korrekt sein, kann der User angemeldet werden. Dazu muss das Authentication-Backend und ein Session Timeout gesetzt werden und der Benutzer über die Funktion \textit{login()} eingeloggt werden:
\begin{lstlisting}
try:
    user = User.objects.get(email='exampleATexample.com')
except:
    user = None
if user is not None and user.check_password('myPassword'):
    user.backend = 'mongoengine.django.auth.MongoEngineBackend'
    login(request, user)
    request.session.set_expiry(60 * 60 * 1) # 1 hour timeout
\end{lstlisting}

Der aktuell angemeldete Benutzer kann mittels \textit{request.user} abgefragt werden. Sollte der Benutzer aktuell nicht angemeldet sein, ist dies null, ansonsten wird das entsprechende User-Objekt zurückgeliefert.
Um einen angemeldeten Benutzer wieder abzumelden muss lediglich folgende Funktion ausgeführt werden:
\textit{logout(request)}

\subsubsection{Usersicht}

\includegraphics[width=0.35\textwidth]{images/usermanagement/Usersicht}\\

Ein angemeldeter Benutzer kann seine Benutzerinformationen nachgiebig unter Kontoeinstellungen ändern. Für die Änderung seiner Daten, muss aus Sicherheitsgründen, dass aktuelle Passwort eingegeben werden.

\includegraphics[width=0.35\textwidth]{images/usermanagement/Kontoeinstellungen}\\

Im System befinden sich drei verschiedene Berechtigungsstufen, welche sind: der Standard-Benutzer, Pro-Benutzer und Administrator. Jedem/r registrierten AnwenderIn ist zu Beginn ein Standard-Benutzer. Ihnen stehen eine begrenzte Anzahl an digitalen Heften zur Verfügung. Durch eine geringe monatliche Zahlung kann der Standard-Account zum Pro-Account upgegradet werden, wodurch dem/r SchülerIn erweiterte Funktion angeboten werden. Zum einen stehen mehr Hefte zur Verfügung, es wird keine Werbung angezeigt, sowie keine Speicherbeschränkung. Die letzte Berechtigungsstufe sind Administratoren. Sie sind ebenfalls Pro-User, haben im Gegensatz einen eigenen Admin-Bereich, wo sämtliche Daten über Benutzer verwaltet und kontrolliert werden können. Dieser Bereich kann mit /admin nach der URL aufgerufen werden. Er unterscheidet sich durch den schwarzen Menübalken.

\subsubsection{Adminsicht}

\includegraphics[width=0.35\textwidth]{images/usermanagement/Adminsicht}\\

Auf der User Management Page werden alle Benutzer von DSN aufgelistet. Man hat Einsicht auf die Email-Adresse, Vorname, Nachname und auf die Berechtigungsstufe, Standard-Benutzer, Pro-Benutzer, Administrator. Außerdem besteht die Möglichkeit als Administrator andere Benutzer zu löschen, die Berechtigungsstufe zu ändern oder den Benutzer mittels einer Mail auf etwas hinzuweisen. Neben der Auflistung der Benutzer, kann auch nach einer bestimmten Person suchen. Die Eingabe wird mit den Vorname, Nachnamen und der Email-Adresse verglichen. Mittels \textit{collectionName.objects()} liefert Mongoengine alle Objekte von der angegeben Collection. Wenn der Adminstrator aber nicht alle Objekte von einer Collection haben möchte, sondern nur eine gewisse Anzahl, können diese mit folgenden Befehl abgefragt werden:\textit{Tabellenname.objects[x:y]}\\
Objekte können wie folgt gesucht werden:\\
\textit{users(Q(email\_\_icontains=suchtext) \big| Q(first\_name\_\_icontains=suchtext) \big|\\
Q(last\_name\_\_icontains=suchtext))}\\
\\
Objekte können auch nach einer bestimmten Spalte sortiert werden.\\
\textit{users.order\_by(spaltenname)
users.order\_by('- '+spaltenname)}\\
\\
Falls man ein vorhandenes Objekt aus der Collection löschen möchte, muss dieses zuvor rausfiltern und dann mit der Funktion \textit{delete()} entfernen. Veränderte Daten werden mit der Funktion \textit{save()} persistiert.

\includegraphics[width=0.65\textwidth]{images/usermanagement/Usermanagment}\\

Da unser User Management Page nur Seitenweise die Benutzerliefert, um Ladezeiten zu minimieren, muss diese mittels Pagination umgesetzt werden. Für die Realisierung sind die Anzahl der Objekte die insgesamt ausgegeben werden sollen gefordert. Dann wird definiert, wieviele Elemente pro Seite angezeigt werden sollen. Um die Seitenanzahl zu berechnen,  werden alle Elemente durch die Anzahl der Elemente dividiert, die pro Seite dargestellt werden sollen. Der Server übergibt dann die Elemente, welche auf einer Seite angezeigt werden sollen. Falls der User auf eine andere Seite wechselt, werden die nächsten Objekte vom Server bezogen.
\begin{lstlisting}
$http({
        method: 'GET',
        url: '/api/admin_user',
        data: {}
    })
        .success(function (data) {
            $scope.users = data['test'];
            $scope.len = data['len'];
            $scope.currentPage = 0;
            $scope.l = Math.ceil($scope.len/$scope.itemsPerPage);
        })
        .error(function (data) {
  });
    var searchMatch = function (haystack, needle) {
        if (!needle) {
            return true;
        }
        return haystack.toLowerCase().indexOf(needle.toLowerCase()) !== -1;
    };

    $scope.range = function (size, start, end) {
        var ret = [];
        if (size < end) {
            end = size;
            start = size;
        }
        for (var i = start; i < end; i++) {
            ret.push(i);
        }
        return ret;
    };

    $scope.firstPage = function () {
        $scope.currentPage = 0;
    };

    $scope.prevPage = function () {
        if ($scope.currentPage > 0) {
            $scope.currentPage--;
        }
    };

    $scope.nextPage = function () {
        if ($scope.currentPage < $scope.l- 1) {
            $scope.currentPage++;
        }
    };

    $scope.lastPage = function () {
        $scope.currentPage = $scope.l-1;
    };

    $scope.setPage = function () {
        $scope.currentPage = this.n;
    };

\end{lstlisting}

\begin{lstlisting}
def view_users(request):
    if not request.user.is_authenticated() or not request.user.is_superuser:
        return JsonResponse({})
    u = []
    length = 0
    weiter = False
    delete = False
    if request.method == "GET":
        users = User.objects[0:20]
        length = len(User.objects)
    elif request.method == "POST":
        params = json.loads(request.body.decode('utf-8'))
        von = (params['Page']-1)*params['counter']
        bis = params['counter']*params['Page']

        try:
            """ Delete """
            user = User.objects.get(email=params['email'])

            if user != request.user and user.delete_date == None:
                enddate = datetime.now() + timedelta(days=7)
                until = date(enddate.year, enddate.month, enddate.day)
                user.delete_date = until
                user.save()
                deleteemail(user.email, user.first_name, until)
            elif user != request.user:
                user.delete_date = None
                user.save()
        except KeyError:
            pass

        users = User.objects()

        try:
            """ Search """
            if bool(params['text'] and params['text'].strip()):
                users = users(Q(email__icontains=params['text']) | Q(first_name__icontains=params['text']) | Q(last_name__icontains=params['text']))
        except KeyError:
            pass

        try:
            """ Sort """
            if params['order'] is not None:
                if params['order']:
                    users = users.order_by(params['spalte'])
                else:
                    users = users.order_by('-'+str(params['spalte']))
        except KeyError:
            pass
        length = len(users)
        users = users[von:bis]
    for user in users:
        security = 1
        if user.is_prouser: security = 2
        if user.is_superuser: security = 3
        if not user.is_active: security = 4
        if user.delete_date == None:
            delete_state = 'Account loeschen'
        else:
            days = abs(datetime.today().day - int(date.strftime(user.delete_date, "%d")))
            delete_state = ' Loeschung in %s Tagen' % (str(days))

        u.append({
            "email": user.email,
            "first_name": user.first_name,
            "last_name": user.last_name,
            "security_level": security,
            "delete_account": delete_state
        })
    if length == 0:
        return JsonResponse({'test': u})
    else:
        return JsonResponse({'test': u, 'len': length})
\end{lstlisting}

Falls ein Pro-User seinen Zahlungen nicht nachkommt oder sich durch Böswilligkeiten bemerkbar macht hat der Administrator von DSN das Recht diesen User zu löschen. DSN gibt den User die Möglichkeit seine Daten bzw. Hefte bevor er gelöscht wird zu sichern. Der zu löschende Benutzer empfängt eine Email, wo darauf hingewiesen wird das sein Account und alle dazugehörigen Daten nach 7 Tagen gelöscht werden. Am Server von DSN läuft ein cronjob welcher jeden Tag das definierte Command, welches überprüft wann der zu löschende User entfernt werden soll, ausführt. Im Falle das jemand länger als 3 Monate interaktiv ist, wird ihm eine Informationsmail zugesendet. Diese informiert ihn, dass er sich in den 7 kommenden Tagen einloggen soll, ansonsten wird der Account mit alle den Daten gelöscht. \cite{COMMANDS}\cite{CRON}

\begin{lstlisting}
from django.core.management import BaseCommand
from datetime import *
from dsn.models import User
from dsn.authentication.account_delete import delete_account

#https://docs.djangoproject.com/en/1.9/howto/custom-management-commands/
#The class must be named Command, and subclass BaseCommand
class Command(BaseCommand):
    # Show this when the user types help
    help = "Command for the User notification"

    # A command must define handle()
    def handle(self, *args, **options):
        until = datetime.now() + timedelta(days=7)
        users = User.objects(delete_date__lte=until)
        for user in users:
            now = datetime.today()
            day = abs(now.day - int(date.strftime(user.delete_date, "%d")))
            if day == 0:#User delete
                delete_account(user)
\end{lstlisting}

Cronjob
\begin{lstlisting}
# m h  dom mon dow   command
# * *   */1   *   *    python3 /home/stable/dsn/manage.py inform
# * *   */1   *   *    python3 /home/stable/dsn/manage.py delete
\end{lstlisting}

Unter dem Navigationspunkt Bills werden die Rechnungen von den Pro-Benutzern aufgelistet. Zum einen wann und ob der Betrag eingezahlt wurde.